# 动态规划-其他

## [地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)

输入一个存储着整数的二维数组`grid`，如果`grid[i][j] > 0`，说明这个格子装着血瓶，经过它可以增加对应的生命值；如果`grid[i][j] == 0`，则这是一个空格子，经过它不会发生任何事情；如果`grid[i][j] < 0`，说明这个格子有怪物，经过它会损失对应的生命值。

问至少需要多少初始生命值，能够让骑士从最左上角移动到最右下角，且任何时候生命值都要大于`0`。

本题关键不在于吃最多的血瓶，而是在于如何损失最少的生命值。

类比前文 最小路径和问题，`dp`函数签名肯定长这样：
```cpp
int dp(vector<vector<int>>& grid, int i, int j);
```
但是这道题对 dp 函数的定义比较有意思，按照常理，这个`dp`函数的定义应该是：

从左上角（`grid[0][0]`）走到`grid[i][j]`至少需要`dp(grid, i, j)`的生命值。

但是这样定义是错误的，因为路上可以加血。正确的做法需要反向思考：从`grid[i][j]`到达终点（右下角）所需的最少生命值是`dp(grid, i, j)`。根据新的`dp`函数定义和`basecase`，我们想求`dp(0, 0)`，那就应该试图通过`dp(i, j+1)`和`dp(i+1, j)`推导出`dp(i, j)`，这样才能不断逼近`basecase`，正确进行状态转移。

故状态转移方程：
```cpp
int res = min(
    dp(i + 1, j),
    dp(i, j + 1)
) - grid[i][j];
// res为至少**需要**的血量，所以要减去grid[i][j]
dp(i, j) = res <= 0 ? 1 : res; // 如果不需要那么多，比如捡到一个超大的血瓶，res当前为1即可。
```
代码：
```cpp
int calculateMinimumHP(vector<vector<int>>& dungeon) {
    int m = dungeon.size();
    int n = dungeon[0].size();
    vector<vector<int>> dp(m, vector<int>(n, 0));
    dp[m-1][n-1] = dungeon[m-1][n-1] < 0 ? -dungeon[m-1][n-1] + 1 : 1;
    for(int i = m-2; i >= 0; --i) dp[i][n-1] = max(dp[i+1][n-1] - dungeon[i][n-1], 1); // 底边处理，dp只能从右往左
    for(int i = n-2; i >= 0; --i) dp[m-1][i] = max(dp[m-1][i+1] - dungeon[m-1][i], 1); // 右边处理，dp只能从下往上
    for(int i = m-2; i >= 0; --i) {
        for(int j = n-2; j >= 0; --j) {
            dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);
        }
    }
    return dp[0][0];
}
```

## [自由之路](https://leetcode-cn.com/problems/freedom-trail/)
圆盘固定，我们可以拨动指针；现在需要我们拨动指针并按下按钮，以最少的操作次数输入`key`对应的字符串。

那么这道题的「状态」就是「当前需要输入的字符」和「当前圆盘指针的位置」。「选择」就是「如何拨动指针得到待输入的字符」。

再具体点，「状态」就是`i`和`j`两个变量。我们可以用`i`表示当前圆盘上指针指向的字符（也就是`ring[i]`）；用`j`表示需要输入的字符（也就是`key[j]`）。

这样我们可以写这样一个`dp`函数：
```cpp
int dp(string ring, int i, string key, int j);
```
这个`dp`函数的定义如下：

>当圆盘指针指向`ring[i]`时，输入字符串`key[j..]`至少需要`dp(ring, i, key, j)`次操作。

根据这个定义，题目其实就是想计算`dp(ring, 0, key, 0)`的值，而且我们可以把`dp`函数的`basecase`写出来：
```cpp
int dp(string ring, int i, string key, int j) {
    // basecase，完成输入
    if (j == key.length()) return 0;
    // ...
}
```
对于选择：就是顺时针或逆时针拨动指针转到对应的字符位置的最少操作次数。
```cpp
int dp(string ring, int i, string key, int j) {
    // base case 完成输入
    if (j == key.length()) return 0;
    
    // 做选择
    int res = INT_MAX;
    for (int k : [字符 key[j] 在 ring 中的所有索引]) {
        res = min(
            把 i 顺时针转到 k 的代价,
            把 i 逆时针转到 k 的代价
        );
    }
    
    return res;
}
```
代码如下：
```cpp
int findRotateSteps(string ring, string key) {
    int n = ring.size(), m = key.size();
    vector<int> pos[26]; // 表示字符 i 在 ring 中出现的位置集合，用来加速计算转移的过程
    for (int i = 0; i < n; ++i) {
        pos[ring[i] - 'a'].push_back(i);
    }
    int dp[m][n];
    memset(dp, 0x3f3f3f3f, sizeof(dp));
    for (auto& i: pos[key[0] - 'a']) {
        dp[0][i] = min(i, n - i) + 1;
    }
    for (int i = 1; i < m; ++i) {
        for (auto& j: pos[key[i] - 'a']) {
            for (auto& k: pos[key[i - 1] - 'a']) {
                dp[i][j] = min(dp[i][j], dp[i - 1][k] + min(abs(j - k), n - abs(j - k)) + 1); // 选出从上一个(i-1)位置k由顺时针/逆时针到当前(i)位置j的最小开销
            }
        }
    }
    return *min_element(dp[m - 1], dp[m - 1] + n);
}
```

## 加权最短路径：[K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)
我第一次想到的方法，可以解出来，但是会超时：
```cpp
int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) { //n为城市数量，k为允许中转的次数
    int sz = flights.size();
    int res = dp(src, dst, sz, flights, k);
    return res == INT_MAX ? -1 : res;
}
int dp(int src, int dst, int nflt, vector<vector<int>>& flights, int k) {
    if(src == dst) return 0;
    int direct = INT_MAX; // 查看有没有直接到达的航班
    for(int i = 0; i < nflt; ++i) {
        if(flights[i][0] == src && flights[i][1] == dst) direct = flights[i][2];
    }
    if(k == 0) return direct;
    int transfer = INT_MAX; // 查看中转的航班
    for(int i = 0; i < nflt; ++i) {
        if(flights[i][0] == src) {
            int temp = dp(flights[i][1], dst, nflt, flights, k-1);
            if(temp == INT_MAX) continue;
            else transfer = min(transfer, flights[i][2] + temp);
        }
    }
    return min(direct, transfer);
}
```
于是要考虑一个二维数组来存储相同子问题，我们用`dp[t][i]`表示通过恰好`t`次航班，从出发城市`src`到达城市`i`需要的最小花费。在进行状态转移时，我们可以枚举最后一次航班的起点`j`，即：`dp[t][i]=min(dp[t-1][j]+cost(j,i))`，其中`{j, i} in flights`。

该状态转移方程的意义在于，枚举最后一次航班的起点`j`，那么前`t−1`次航班的最小花费为`dp[t−1][j]`加上最后一次航班的花费`cost(j,i)`中的最小值，即为`dp[t][i]`。由于我们最多只能中转`k`次，也就是最多搭乘`k+1`次航班，最终的答案即为`dp[1][dst],dp[2][dst],⋯,dp[k+1][dst]`中的最小值。

细节：当`t=0`时，状态`dp[t][i]`表示不搭乘航班到达城市`i`的最小花费，因此有：`dp[t][i]=0 if i == src else dp[t][i] = +inf`

也就是说，如果`i`是出发城市`src`，那么花费为`0`；否则`dp[0][i]`不是一个合法的状态，由于在状态转移方程中我们需要求出的是最小值，因此可以将不合法的状态置为极大值`+inf`。
```cpp
int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
    vector<vector<int>> dp(k + 2, vector<int>(n, 100001)); // 将数组初始化为一个很大的数
    dp[0][src] = 0; // basecase，dp[0][others]都为+inf，因为非起点，意为不能通过0次航班从src到others
    for (int t = 1; t <= k + 1; ++t) { // 可以搭乘k+1次飞机
        for (auto& flight: flights) {
            int j = flight[0], i = flight[1], cost = flight[2];
            dp[t][i] = min(dp[t][i], dp[t - 1][j] + cost);
        }
    }
    int ans = 100001;
    for (int t = 1; t <= k + 1; ++t) {
        ans = min(ans, dp[t][dst]); // 选择dp[..][dst] 到目的地花销最小的cost
    }
    return (ans == 100001 ? -1 : ans);
}
```
