# 二分搜索

## 二分查找模版
分析二分查找的一个技巧：不要出现else，而是把所有情况用else if写清楚，这样可以清楚地展现所有细节。
```cpp
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;
    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```
代码中`left + (right - left) / 2`就和`(left + right) / 2`的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。

## 寻找一个数（基本的二分搜索）
即搜索一个数，如果存在，返回其索引，否则返回 -1
```cpp
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
```
1. 为什么 while 循环的条件中是 <=，而不是 <？  
   + 因为初始化`right`的赋值是`nums.length - 1`，即最后一个元素的索引，而不是`nums.length`。  
   + 这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间`[left, right]`，后者相当于左闭右开区间`[left, right)`，因为索引大+ 小为 nums.length 是越界的。  
   这个算法中使用的是前者`[left, right]`两端都闭的区间。这个区间其实就是每次进行搜索的区间。
   + `while(left <= right)`的终止条件是`left == right + 1`，写成区间的形式就是`[right + 1, right]`，或者带个具体的数字进去`[3, 2]`，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。
   + `while(left < right)`的终止条件是`left == right`，写成区间的形式就是`[right, right]`，或者带个具体的数字进去`[2, 2]`，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间`[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。
2. 为什么`left = mid + 1`，`right = mid - 1`？
   + 本算法的搜索区间是两端都闭的，即`[left, right]`。那么当我们发现索引`mid`不是要找的`target`时，下一步应该去搜索`[left, mid-1]`或者`[mid+1, right]`，因为`mid`已经搜索过，应该从搜索区间中去除。