# 图论

## 遍历
如为无环图，可以不使用`visited`数组，以该题[所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)为例写出以邻接表为存储的图的遍历
```cpp
void traverse(vector<vector<int>>& graph, vector<int> path, int loc, int n) {
    path.push_back(loc); // 添加当前节点到路径中
    if(loc == n-1) {
        res.push_back(path); // 遍历到终点，n为节点个数，将该路径添加到res中
        return;
    }
    for(auto& point: graph[loc]) {
        traverse(graph, path, point, n); // 递归遍历，注意path变量不能是引用类型
    }
    path.pop_back(); // 从路径中删除当前节点
    return;
}
```

## 拓扑排序：有向图的环检测、拓扑排序算法
环检测算法：[课程表](https://leetcode-cn.com/problems/course-schedule/)。算法需要一个`visited`数组来记录访问过的节点，但并不是说访问过的节点再被访问一次就证明有环，因为DFS中可能存在两个不同节点同时指向一个节点的情况。于是还需要一个`onPath`数组来存放在当前遍历路径上的节点。在进入节点`s`的时候将`onPath[s]`标记为`true`，离开时标记回`false`，如果发现`onPath[s]`已经被标记，说明出现了环。
```cpp
void traverse(vector<vector<int>>& graph, vector<bool>& visited, vector<bool>& onPath, int loc) { // 有向图检测环的算法
    if(onPath[loc]) {
        hasCycle = true;
    }
    if(visited[loc] || hasCycle) return;
    onPath[loc] = true;
    visited[loc] = true;
    for(auto& point: graph[loc]) {
        traverse(graph, visited, onPath, point);
    }
    onPath[loc] = false;
}
```

拓扑排序算法：[课程表II](https://leetcode-cn.com/problems/course-schedule-ii/)。跟上述算法类似，也是先判断是否有环，不过存储路径时要后序存储，然后将后序存储的路径逆序便是拓扑排序的路径。对`traverse`函数修改如下：
```cpp
void traverse(vector<vector<int>>& graph, vector<bool>& visited, vector<bool>& onPath, int loc) {
    if(onPath[loc]) {
        hasCycle = true;
    }
    if(visited[loc] || hasCycle) return;
    onPath[loc] = true;
    visited[loc] = true;
    for(auto& point: graph[loc]) {
        traverse(graph, visited, onPath, point);
    }
    onPath[loc] = false;
    postOrder.push_back(loc); // 将路径添加到后序路径中
}
```
解释是：可以将拓扑排序的图理解为一棵树（二叉树），该二叉树（抽象为有向的图）的后序遍历一定是从叶子到根的，而后序遍历的逆序就是拓扑的。

